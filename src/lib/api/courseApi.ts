
import { supabase } from '@/integrations/supabase/client';

export const fetchCourses = async () => {
  try {
    console.log("Fetching courses...");
    const { data, error } = await supabase
      .from('courses')
      .select('*');
    
    if (error) {
      console.error("Error fetching courses:", error);
      throw error;
    }
    
    console.log("Fetched courses:", data);
    return data || [];
  } catch (e) {
    console.error("Exception in fetchCourses:", e);
    throw e;
  }
};

export const fetchCourseById = async (courseId: string) => {
  try {
    console.log("Fetching course details for:", courseId);
    const { data, error } = await supabase
      .from('courses')
      .select('*')
      .eq('id', courseId)
      .single();
    
    if (error) {
      console.error("Error fetching course details:", error);
      throw error;
    }
    
    console.log("Fetched course details:", data);
    return data;
  } catch (e) {
    console.error("Exception in fetchCourseById:", e);
    throw e;
  }
};

export const updateCourseProgress = async (courseId: string, progress: number, currentLessonIndex?: number) => {
  try {
    console.log("Starting updateCourseProgress for course:", courseId);
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      console.error("No authenticated user found");
      throw new Error('No user found');
    }
    
    console.log("User authenticated:", user.id);

    const { data: existingProgress, error: selectError } = await supabase
      .from('course_progress')
      .select('*')
      .eq('user_id', user.id)
      .eq('course_id', courseId)
      .maybeSingle();
    
    if (selectError) {
      console.error("Error checking existing progress:", selectError);
    }
    
    console.log("Existing progress:", existingProgress);

    const progressData = {
      user_id: user.id,
      course_id: courseId,
      progress_percentage: progress,
      completed: progress === 100,
      last_accessed: new Date().toISOString(),
      current_lesson_index: currentLessonIndex !== undefined ? currentLessonIndex : existingProgress?.current_lesson_index || 0
    };
    
    console.log("Upserting progress data:", progressData);

    const { data, error } = await supabase
      .from('course_progress')
      .upsert([progressData], {
        onConflict: 'user_id,course_id'
      })
      .select();

    if (error) {
      console.error("Error upserting course progress:", error);
      throw error;
    }
    
    console.log("Successfully updated course progress:", data);

    if (progress === 100) {
      await generateCertificate(courseId);
      await awardCourseBadge(courseId);
    }

    return { success: true, data };
  } catch (error) {
    console.error('Error in updateCourseProgress:', error);
    throw error;
  }
};

export const generateCertificate = async (courseId: string) => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('No user found');

    const { data: course, error: courseError } = await supabase
      .from('courses')
      .select('*')
      .eq('id', courseId)
      .single();

    if (courseError || !course) {
      console.error("Error finding course:", courseError);
      throw new Error('Course not found');
    }

    const { data: existingCert, error: checkError } = await supabase
      .from('certificates')
      .select('id')
      .eq('user_id', user.id)
      .eq('course_id', courseId)
      .maybeSingle();
    
    if (checkError) {
      console.error("Error checking for existing certificate:", checkError);
    }
    
    if (!existingCert) {
      console.log("Creating new certificate for course:", course.title);
      const { data, error } = await supabase
        .from('certificates')
        .insert([
          {
            user_id: user.id,
            course_id: courseId,
            name: `${course.title} Certificate`,
            description: `Certificate of completion for ${course.title}`,
            download_url: `/certificates/${courseId}.pdf`, // This would be generated by a backend service
            earned_date: new Date().toISOString()
          }
        ])
        .select();

      if (error) {
        console.error("Error generating certificate:", error);
        throw error;
      }
      
      console.log("Certificate created successfully:", data);
      return data;
    } else {
      console.log("Certificate already exists, skipping creation");
      return existingCert;
    }
  } catch (e) {
    console.error("Exception in generateCertificate:", e);
    throw e;
  }
};

export const awardCourseBadge = async (courseId: string) => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('No user found');

    const { data: course, error: courseError } = await supabase
      .from('courses')
      .select('*')
      .eq('id', courseId)
      .single();

    if (courseError || !course) {
      console.error("Error finding course:", courseError);
      throw new Error('Course not found');
    }

    const { data: badges, error: badgesError } = await supabase
      .from('badges')
      .select('*')
      .eq('category', 'course')
      .limit(1);
    
    if (badgesError) {
      console.error("Error finding badges:", badgesError);
      return;
    }
    
    if (!badges || badges.length === 0) {
      console.log("No badges found, creating a default badge");
      const { data: newBadge, error: createError } = await supabase
        .from('badges')
        .insert([
          {
            name: 'Course Completion',
            description: 'Awarded for completing a course',
            tier: 'bronze',
            category: 'course',
            image_url: '/badges/course-completion.png'
          }
        ])
        .select();
        
      if (createError || !newBadge || newBadge.length === 0) {
        console.error("Error creating badge:", createError);
        return;
      }
      
      const { data, error } = await supabase
        .from('user_badges')
        .insert([
          {
            user_id: user.id,
            badge_id: newBadge[0].id,
            earned_date: new Date().toISOString()
          }
        ])
        .select();
        
      if (error) {
        console.error("Error awarding badge:", error);
      }
      
      return data;
    }

    const { data, error } = await supabase
      .from('user_badges')
      .insert([
        {
          user_id: user.id,
          badge_id: badges[0].id,
          earned_date: new Date().toISOString()
        }
      ])
      .select();

    if (error) {
      console.error("Error awarding badge:", error);
      throw error;
    }
    
    return data;
  } catch (e) {
    console.error("Exception in awardCourseBadge:", e);
    return null;
  }
};

export const generateAssessment = async (courseId: string, difficulty: string, subject: string) => {
  try {
    console.log(`Generating ${difficulty} assessment for course ${courseId}`);
    
    // In a production app, this would call an AI service or backend API
    // For now, we're generating mock data
    
    const questionCount = difficulty === 'beginner' ? 5 : difficulty === 'intermediate' ? 8 : 10;
    
    const mockQuestions = [...Array(questionCount)].map((_, index) => ({
      id: index + 1,
      text: `Sample question ${index + 1} about ${subject} (${difficulty} level)`,
      options: [
        `Option A for question ${index + 1}`,
        `Option B for question ${index + 1}`,
        `Option C for question ${index + 1}`,
        `Option D for question ${index + 1}`
      ],
      correctAnswer: Math.floor(Math.random() * 4) // Random correct answer
    }));
    
    const assessment = {
      id: `assessment-${courseId}-${difficulty}`,
      title: `${subject} Assessment`,
      description: `Test your knowledge of ${subject} concepts at the ${difficulty} level.`,
      difficulty: difficulty as 'beginner' | 'intermediate' | 'advanced',
      questions: mockQuestions
    };
    
    console.log("Generated assessment:", assessment);
    return assessment;
  } catch (e) {
    console.error("Exception in generateAssessment:", e);
    throw e;
  }
};
